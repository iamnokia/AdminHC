import { useState, useEffect } from 'react';
import axios from 'axios';
import * as Papa from 'papaparse';
import _ from 'lodash';

// Define types based on actual API response
interface ServiceOrder {
  employee_id: number;
  first_name: string;
  last_name: string;
  user_id: number;
  cat_id: number;
  amount: number;
  address_users_detail_id: number;
  payment_status: string;
  order_date: string;
  updated_at: string;
  // Mapped fields for compatibility
  id?: number;
  order_id?: string;
  customer_id?: number;
  service_date?: string;
  service_time?: string;
  service_type?: string;
  status?: string;
  created_at?: string;
}

interface FilterParams {
  page: number;
  limit: number;
  startDate: string | null;
  endDate: string | null;
  serviceType: string | null;
  growthRateType: string;
}

interface UsageDataPoint {
  name: string;
  sessions: number;
  users: number;
}

interface GrowthRate {
  sessions: number;
  users: number;
}

interface SummaryData {
  totalSessions: number;
  totalUsers: number;
  averageSessionsPerUser: number;
  growthRate: GrowthRate;
  currentPeriodLabel: string;
  previousPeriodLabel: string;
  currentPeriodSessions: number;
  previousPeriodSessions: number;
  currentPeriodUsers: number;
  previousPeriodUsers: number;
}

export const useServiceReportController = () => {
  // State for filtering and data
  const [filterOpen, setFilterOpen] = useState<boolean>(false);
  const [filterParams, setFilterParams] = useState<FilterParams>({
    page: 1,
    limit: 100,
    startDate: null,
    endDate: null,
    serviceType: null,
    growthRateType: 'monthly'
  });
  
  // Data states
  const [serviceOrders, setServiceOrders] = useState<ServiceOrder[]>([]);
  const [usageData, setUsageData] = useState<UsageDataPoint[]>([]);
  const [summaryData, setSummaryData] = useState<SummaryData>({
    totalSessions: 0,
    totalUsers: 0,
    averageSessionsPerUser: 0,
    growthRate: { sessions: 0, users: 0 },
    currentPeriodLabel: '',
    previousPeriodLabel: '',
    currentPeriodSessions: 0,
    previousPeriodSessions: 0,
    currentPeriodUsers: 0,
    previousPeriodUsers: 0
  });
  
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [debugInfo, setDebugInfo] = useState<string>('');

  // Map API response to expected format
  const mapApiResponse = (apiData: any[]): ServiceOrder[] => {
    return apiData.map((item, index) => ({
      // Original API fields
      employee_id: item.employee_id || 0,
      first_name: item.first_name || '',
      last_name: item.last_name || '',
      user_id: item.user_id || 0,
      cat_id: item.cat_id || 0,
      amount: item.amount || 0,
      address_users_detail_id: item.address_users_detail_id || 0,
      payment_status: item.payment_status || '',
      order_date: item.order_date || '',
      updated_at: item.updated_at || '',
      
      // Mapped fields for compatibility
      id: item.employee_id || index + 1,
      order_id: `ORD-${item.employee_id || index + 1}`,
      customer_id: item.user_id || 0,
      service_date: item.order_date || '',
      service_time: item.order_date ? new Date(item.order_date).toLocaleTimeString('lo-LA', { hour: '2-digit', minute: '2-digit' }) : '',
      service_type: item.cat_id === 1 ? '‡∫Å‡∫≤‡∫ô‡∫û‡∫∞‡∫ç‡∫≤‡∫ö‡∫≤‡∫ô' : 
                   item.cat_id === 2 ? '‡∫Å‡∫≤‡∫ô‡∫ó‡∫≥‡∫Ñ‡∫ß‡∫≤‡∫°‡∫™‡∫∞‡∫≠‡∫≤‡∫î' : 
                   item.cat_id === 3 ? '‡∫Å‡∫≤‡∫ô‡∫î‡∫π‡ªÅ‡∫•‡∫™‡∫∏‡∫Ç‡∫∞‡∫û‡∫≤‡∫ö' : '‡∫ö‡ªç‡∫•‡∫¥‡∫Å‡∫≤‡∫ô‡∫≠‡∫∑‡ªà‡∫ô‡ªÜ',
      status: item.payment_status || 'unknown',
      created_at: item.order_date || '',
    }));
  };

  // Toggle filter panel
  const toggleFilter = () => {
    setFilterOpen(!filterOpen);
  };

  // Handle basic filter changes
  const handleFilterChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    const numValue = parseInt(value);
    
    if (!isNaN(numValue) && numValue > 0) {
      setFilterParams(prev => ({
        ...prev,
        [name]: numValue
      }));
    }
  };

  // Handle date changes
  const handleDateChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFilterParams(prev => ({
      ...prev,
      [name]: value || null
    }));
  };

  // Handle service type changes
  const handleServiceTypeChange = (e: React.ChangeEvent<{ name?: string, value: unknown }>) => {
    const value = e.target.value as string;
    setFilterParams(prev => ({
      ...prev,
      serviceType: value || null
    }));
  };
  
  // Handle growth rate type changes
  const handleGrowthRateTypeChange = (e: React.ChangeEvent<{ name?: string, value: unknown }>) => {
    const value = e.target.value as string;
    setFilterParams(prev => ({
      ...prev,
      growthRateType: value
    }));
  };

  // Simple API test function
  const testAPI = async () => {
    console.log('üîç Testing API connection...');
    setDebugInfo('Testing API...');
    
    try {
      const response = await axios.get('https://homecare-pro.onrender.com/reports/service_orders', {
        timeout: 10000
      });
      
      console.log('‚úÖ Raw API Response:', response);
      console.log('üìä Response Status:', response.status);
      console.log('üìä Response Headers:', response.headers);
      console.log('üìä Response Data:', response.data);
      
      setDebugInfo(`API Response: ${JSON.stringify(response.data, null, 2)}`);
      
      return response.data;
    } catch (error) {
      console.error('‚ùå API Test Error:', error);
      setDebugInfo(`API Error: ${error.message}`);
      throw error;
    }
  };

  // Fetch service orders from the API
  const fetchServiceOrders = async () => {
    setLoading(true);
    setError(null);
    setDebugInfo('Starting fetch...');
    
    try {
      console.log('üöÄ Starting API call...');
      
      // Build the URL with query parameters
      const baseUrl = 'https://homecare-pro.onrender.com/reports/service_orders';
      const params = new URLSearchParams();
      
      params.append('page', filterParams.page.toString());
      params.append('limit', filterParams.limit.toString());
      
      if (filterParams.startDate) {
        params.append('startDate', filterParams.startDate);
      }
      
      if (filterParams.endDate) {
        params.append('endDate', filterParams.endDate);
      }
      
      if (filterParams.serviceType) {
        params.append('serviceType', filterParams.serviceType);
      }
      
      const fullUrl = `${baseUrl}?${params.toString()}`;
      console.log('üåê Full URL:', fullUrl);
      setDebugInfo(`Calling: ${fullUrl}`);
      
      // Make the API request
      const response = await axios.get(fullUrl, {
        timeout: 15000,
        headers: {
          'Accept': 'application/json',
          'Content-Type': 'application/json'
        }
      });
      
      console.log('üìã Full Response Object:', response);
      console.log('üìä Response Status:', response.status);
      console.log('üìä Response Data:', response.data);
      console.log('üìä Response Type:', typeof response.data);
      console.log('üìä Is Array:', Array.isArray(response.data));
      
  // Map API response to expected format
  const mapApiResponse = (apiData: any[]): ServiceOrder[] => {
    return apiData.map((item, index) => ({
      // Original API fields
      employee_id: item.employee_id || 0,
      first_name: item.first_name || '',
      last_name: item.last_name || '',
      user_id: item.user_id || 0,
      cat_id: item.cat_id || 0,
      amount: item.amount || 0,
      address_users_detail_id: item.address_users_detail_id || 0,
      payment_status: item.payment_status || '',
      order_date: item.order_date || '',
      updated_at: item.updated_at || '',
      
      // Mapped fields for compatibility
      id: item.employee_id || index + 1,
      order_id: `ORD-${item.employee_id || index + 1}`,
      customer_id: item.user_id || 0,
      service_date: item.order_date || '',
      service_time: item.order_date ? new Date(item.order_date).toLocaleTimeString('lo-LA', { hour: '2-digit', minute: '2-digit' }) : '',
      service_type: item.cat_id === 1 ? '‡∫Å‡∫≤‡∫ô‡∫û‡∫∞‡∫ç‡∫≤‡∫ö‡∫≤‡∫ô' : 
                   item.cat_id === 2 ? '‡∫Å‡∫≤‡∫ô‡∫ó‡∫≥‡∫Ñ‡∫ß‡∫≤‡∫°‡∫™‡∫∞‡∫≠‡∫≤‡∫î' : 
                   item.cat_id === 3 ? '‡∫Å‡∫≤‡∫ô‡∫î‡∫π‡ªÅ‡∫•‡∫™‡∫∏‡∫Ç‡∫∞‡∫û‡∫≤‡∫ö' : '‡∫ö‡ªç‡∫•‡∫¥‡∫Å‡∫≤‡∫ô‡∫≠‡∫∑‡ªà‡∫ô‡ªÜ',
      status: item.payment_status || 'unknown',
      created_at: item.order_date || '',
    }));
  };
      // Try to extract data from different possible structures
      let rawData = [];
      
      if (response.data) {
        // Log all possible properties
        console.log('üîç Response data keys:', Object.keys(response.data));
        
        if (Array.isArray(response.data)) {
          rawData = response.data;
          console.log('‚úÖ Data is direct array');
        } else if (response.data.data && Array.isArray(response.data.data)) {
          rawData = response.data.data;
          console.log('‚úÖ Data found in .data property');
        } else if (response.data.result && Array.isArray(response.data.result)) {
          rawData = response.data.result;
          console.log('‚úÖ Data found in .result property');
        } else if (response.data.results && Array.isArray(response.data.results)) {
          rawData = response.data.results;
          console.log('‚úÖ Data found in .results property');
        } else if (response.data.orders && Array.isArray(response.data.orders)) {
          rawData = response.data.orders;
          console.log('‚úÖ Data found in .orders property');
        } else if (response.data.serviceOrders && Array.isArray(response.data.serviceOrders)) {
          rawData = response.data.serviceOrders;
          console.log('‚úÖ Data found in .serviceOrders property');
        } else {
          console.log('‚ùì Unexpected response structure:', response.data);
          setDebugInfo('Unexpected response structure. Check console for details.');
        }
      }
      
      console.log('üìà Raw API data:', rawData);
      console.log('üìà Raw data length:', rawData.length);
      console.log('üìà First raw item:', rawData[0]);
      
      // Map API response to expected format
      const data = mapApiResponse(rawData);
      
      console.log('üìà Mapped data:', data);
      console.log('üìà Mapped data length:', data.length);
      console.log('üìà First mapped item:', data[0]);
      
      setDebugInfo(`Found ${data.length} records`);
      
      // Update service orders
      setServiceOrders(data);
      
      // Process data for charts and summary
      processDataForCharts(data);
      
      if (data.length === 0) {
        setError('‡∫ö‡ªç‡ªà‡∫°‡∫µ‡∫Ç‡ªç‡ªâ‡∫°‡∫π‡∫ô‡∫™‡∫≥‡∫•‡∫±‡∫ö‡∫Å‡∫≤‡∫ô‡ªÄ‡∫•‡∫∑‡∫≠‡∫Å‡∫õ‡∫∞‡∫à‡∫∏‡∫ö‡∫±‡∫ô');
      }
      
    } catch (err) {
      console.error('üí• Fetch Error:', err);
      console.error('üí• Error Details:', {
        message: err.message,
        status: err.response?.status,
        statusText: err.response?.statusText,
        data: err.response?.data,
        url: err.config?.url
      });
      
      let errorMessage = '‡∫ö‡ªç‡ªà‡∫™‡∫≤‡∫°‡∫≤‡∫î‡∫î‡∫∂‡∫á‡∫Ç‡ªç‡ªâ‡∫°‡∫π‡∫ô‡ªÑ‡∫î‡ªâ. ‡∫Å‡∫∞‡∫•‡∫∏‡∫ô‡∫≤‡∫•‡∫≠‡∫á‡ªÉ‡ªù‡ªà‡∫û‡∫≤‡∫ç‡∫´‡∫º‡∫±‡∫á.';
      
      if (err.code === 'ECONNABORTED') {
        errorMessage = '‡∫Å‡∫≤‡∫ô‡ªÄ‡∫ä‡∫∑‡ªà‡∫≠‡∫°‡∫ï‡ªç‡ªà‡ªÉ‡∫ä‡ªâ‡ªÄ‡∫ß‡∫•‡∫≤‡∫ô‡∫≤‡∫ô‡ªÄ‡∫Å‡∫µ‡∫ô‡ªÑ‡∫õ. ‡∫Å‡∫∞‡∫•‡∫∏‡∫ô‡∫≤‡∫•‡∫≠‡∫á‡ªÉ‡ªù‡ªà.';
      } else if (err.response?.status === 404) {
        errorMessage = '‡∫ö‡ªç‡ªà‡∫û‡∫ª‡∫ö endpoint ‡∫ô‡∫µ‡ªâ. ‡∫Å‡∫∞‡∫•‡∫∏‡∫ô‡∫≤‡∫Å‡∫ß‡∫î‡∫™‡∫≠‡∫ö URL.';
      } else if (err.response?.status === 401) {
        errorMessage = '‡∫ö‡ªç‡ªà‡∫°‡∫µ‡∫™‡∫¥‡∫î‡ªÄ‡∫Ç‡∫ª‡ªâ‡∫≤‡ªÄ‡∫ñ‡∫¥‡∫á. ‡∫ï‡ªâ‡∫≠‡∫á‡∫Å‡∫≤‡∫ô‡∫Å‡∫≤‡∫ô‡∫¢‡∫±‡ªâ‡∫á‡∫¢‡∫∑‡∫ô.';
      } else if (err.response?.status === 403) {
        errorMessage = '‡∫ñ‡∫∑‡∫Å‡∫õ‡∫∞‡∫ï‡∫¥‡ªÄ‡∫™‡∫î‡∫Å‡∫≤‡∫ô‡ªÄ‡∫Ç‡∫ª‡ªâ‡∫≤‡ªÄ‡∫ñ‡∫¥‡∫á.';
      } else if (err.response?.status >= 500) {
        errorMessage = '‡ªÄ‡∫Å‡∫µ‡∫î‡∫Ç‡ªç‡ªâ‡∫ú‡∫¥‡∫î‡∫û‡∫≤‡∫î‡ªÉ‡∫ô‡ªÄ‡∫ä‡∫µ‡ªÄ‡∫ß‡∫µ.';
      } else if (err.code === 'ERR_NETWORK') {
        errorMessage = '‡∫ö‡∫±‡∫ô‡∫´‡∫≤‡ªÄ‡∫Ñ‡∫∑‡∫≠‡∫Ç‡ªà‡∫≤‡∫ç. ‡∫Å‡∫∞‡∫•‡∫∏‡∫ô‡∫≤‡∫Å‡∫ß‡∫î‡∫™‡∫≠‡∫ö‡∫Å‡∫≤‡∫ô‡ªÄ‡∫ä‡∫∑‡ªà‡∫≠‡∫°‡∫ï‡ªç‡ªà.';
      }
      
      setError(errorMessage);
      setDebugInfo(`Error: ${err.message}`);
      
      // Set empty data
      setServiceOrders([]);
      setUsageData([]);
      setSummaryData({
        totalSessions: 0,
        totalUsers: 0,
        averageSessionsPerUser: 0,
        growthRate: { sessions: 0, users: 0 },
        currentPeriodLabel: '',
        previousPeriodLabel: '',
        currentPeriodSessions: 0,
        previousPeriodSessions: 0,
        currentPeriodUsers: 0,
        previousPeriodUsers: 0
      });
    } finally {
      setLoading(false);
    }
  };

  // Process the service orders data for charts and summary  
  const processDataForCharts = (data: ServiceOrder[]) => {
    if (!data || data.length === 0) {
      setUsageData([]);
      setSummaryData({
        totalSessions: 0,
        totalUsers: 0,
        averageSessionsPerUser: 0,
        growthRate: { sessions: 0, users: 0 },
        currentPeriodLabel: '',
        previousPeriodLabel: '',
        currentPeriodSessions: 0,
        previousPeriodSessions: 0,
        currentPeriodUsers: 0,
        previousPeriodUsers: 0
      });
      return;
    }

    console.log('üìä Processing data for charts:', data.length, 'items');

    // Determine grouping based on growthRateType
    let groupByFunction;
    
    switch(filterParams.growthRateType) {
      case 'yearly':
        groupByFunction = (order: ServiceOrder) => {
          const date = new Date(order.service_date || order.order_date);
          return date.getFullYear().toString();
        };
        break;
      case 'quarterly':
        groupByFunction = (order: ServiceOrder) => {
          const date = new Date(order.service_date || order.order_date);
          const quarter = Math.floor(date.getMonth() / 3) + 1;
          return `Q${quarter} ${date.getFullYear()}`;
        };
        break;
      case 'monthly':
      default:
        groupByFunction = (order: ServiceOrder) => {
          const date = new Date(order.service_date || order.order_date);
          return date.toLocaleString('lo-LA', { month: 'short', year: 'numeric' });
        };
    }
    
    // Group by period
    const groupedByPeriod = _.groupBy(data, groupByFunction);
    console.log('üìä Grouped by period:', groupedByPeriod);
    
    // Count unique customers per period
    const periodData = Object.entries(groupedByPeriod).map(([period, orders]) => {
      const uniqueUsers = _.uniqBy(orders, (order) => order.customer_id || order.user_id).length;
      
      return {
        name: period,
        sessions: orders.length,
        users: uniqueUsers,
        date: new Date(orders[0].service_date || orders[0].order_date)
      };
    });
    
    // Sort by date
    const sortedData = _.sortBy(periodData, 'date');
    console.log('üìä Sorted data:', sortedData);
    
    // Remove date property before setting state
    const cleanData = sortedData.map(({ name, sessions, users }) => ({ 
      name, sessions, users 
    }));
    
    setUsageData(cleanData);
    
    // Calculate summary data
    const totalSessions = data.length;
    const totalUsers = _.uniqBy(data, (order) => order.customer_id || order.user_id).length;
    const averageSessionsPerUser = totalUsers > 0 ? totalSessions / totalUsers : 0;
    
    // Calculate growth rates
    let sessionsGrowthRate = 0;
    let usersGrowthRate = 0;
    let currentPeriodLabel = '';
    let previousPeriodLabel = '';
    let currentPeriodSessions = 0;
    let previousPeriodSessions = 0;
    let currentPeriodUsers = 0;
    let previousPeriodUsers = 0;
    
    if (sortedData.length >= 2) {
      const currentPeriod = sortedData[sortedData.length - 1];
      const previousPeriod = sortedData[sortedData.length - 2];
      
      currentPeriodLabel = currentPeriod.name;
      previousPeriodLabel = previousPeriod.name;
      currentPeriodSessions = currentPeriod.sessions;
      previousPeriodSessions = previousPeriod.sessions;
      currentPeriodUsers = currentPeriod.users;
      previousPeriodUsers = previousPeriod.users;
      
      if (previousPeriod.sessions > 0) {
        sessionsGrowthRate = ((currentPeriod.sessions - previousPeriod.sessions) / previousPeriod.sessions) * 100;
      }
      
      if (previousPeriod.users > 0) {
        usersGrowthRate = ((currentPeriod.users - previousPeriod.users) / previousPeriod.users) * 100;
      }
    }
    
    setSummaryData({
      totalSessions,
      totalUsers,
      averageSessionsPerUser,
      growthRate: {
        sessions: sessionsGrowthRate,
        users: usersGrowthRate
      },
      currentPeriodLabel,
      previousPeriodLabel,
      currentPeriodSessions,
      previousPeriodSessions,
      currentPeriodUsers,
      previousPeriodUsers
    });

    console.log('‚úÖ Chart data processed successfully');
  };

  // Mock data for testing
  const useMockData = () => {
    console.log('üé≠ Using mock data...');
    
    const mockApiData = [
      {
        employee_id: 1,
        first_name: '‡∫™‡∫ª‡∫°‡∫û‡∫≠‡∫ô',
        last_name: '‡∫ß‡∫ª‡∫á‡∫™‡∫µ',
        user_id: 101,
        cat_id: 1,
        amount: 150000,
        address_users_detail_id: 201,
        payment_status: 'paid',
        order_date: '2025-05-01T10:00:00.000Z',
        updated_at: '2025-05-01T12:00:00.000Z'
      },
      {
        employee_id: 2,
        first_name: '‡∫°‡∫≤‡∫•‡∫µ',
        last_name: '‡∫û‡∫ª‡∫°‡∫°‡∫∞',
        user_id: 102,
        cat_id: 2,
        amount: 200000,
        address_users_detail_id: 202,
        payment_status: 'paid',
        order_date: '2025-05-02T14:00:00.000Z',
        updated_at: '2025-05-02T16:00:00.000Z'
      },
      {
        employee_id: 3,
        first_name: '‡∫™‡∫µ‡∫î‡∫≤',
        last_name: '‡∫Ñ‡∫≥',
        user_id: 103,
        cat_id: 3,
        amount: 350000,
        address_users_detail_id: 203,
        payment_status: 'paid',
        order_date: '2025-05-03T09:00:00.000Z',
        updated_at: '2025-05-03T11:00:00.000Z'
      },
      {
        employee_id: 1,
        first_name: '‡∫™‡∫ª‡∫°‡∫û‡∫≠‡∫ô',
        last_name: '‡∫ß‡∫ª‡∫á‡∫™‡∫µ',
        user_id: 101,
        cat_id: 1,
        amount: 200000,
        address_users_detail_id: 201,
        payment_status: 'paid',
        order_date: '2025-05-04T15:00:00.000Z',
        updated_at: '2025-05-04T17:00:00.000Z'
      },
      {
        employee_id: 4,
        first_name: '‡∫ö‡∫∏‡∫ô‡∫°‡∫µ',
        last_name: '‡ªÅ‡∫Å‡ªâ‡∫ß',
        user_id: 104,
        cat_id: 2,
        amount: 200000,
        address_users_detail_id: 204,
        payment_status: 'paid',
        order_date: '2025-05-05T11:00:00.000Z',
        updated_at: '2025-05-05T13:00:00.000Z'
      }
    ];
    
    const mappedMockData = mapApiResponse(mockApiData);
    setServiceOrders(mappedMockData);
    processDataForCharts(mappedMockData);
    setError(null);
    setDebugInfo('Using mock data for testing');
  };

  // Apply filters and fetch data
  const applyFilters = async () => {
    await fetchServiceOrders();
  };

  // Reset filters to default
  const resetFilters = () => {
    setFilterParams({
      page: 1,
      limit: 100,
      startDate: null,
      endDate: null,
      serviceType: null,
      growthRateType: 'monthly'
    });
  };

  // Export data to CSV with proper Lao font support
  const handleExport = () => {
    if (!serviceOrders.length) {
      alert('‡∫ö‡ªç‡ªà‡∫°‡∫µ‡∫Ç‡ªç‡ªâ‡∫°‡∫π‡∫ô‡∫™‡∫≥‡∫•‡∫±‡∫ö‡∫Å‡∫≤‡∫ô‡∫™‡∫ª‡ªà‡∫á‡∫≠‡∫≠‡∫Å');
      return;
    }
    
    try {
      // Prepare data for export with Lao headers using actual API fields
      const exportData = serviceOrders.map(order => ({
        '‡∫•‡∫∞‡∫´‡∫±‡∫î‡∫û‡∫∞‡∫ô‡∫±‡∫Å‡∫á‡∫≤‡∫ô': order.employee_id || '',
        '‡∫ä‡∫∑‡ªà': order.first_name || '',
        '‡∫ô‡∫≤‡∫°‡∫™‡∫∞‡∫Å‡∫∏‡∫ô': order.last_name || '',
        '‡∫•‡∫∞‡∫´‡∫±‡∫î‡∫•‡∫π‡∫Å‡∫Ñ‡ªâ‡∫≤': order.user_id || '',
        '‡∫õ‡∫∞‡ªÄ‡∫û‡∫î‡∫ö‡ªç‡∫•‡∫¥‡∫Å‡∫≤‡∫ô': order.cat_id || '',
        '‡∫à‡∫≥‡∫ô‡∫ß‡∫ô‡ªÄ‡∫á‡∫¥‡∫ô': order.amount || '',
        '‡∫•‡∫∞‡∫´‡∫±‡∫î‡∫ó‡∫µ‡ªà‡∫¢‡∫π‡ªà': order.address_users_detail_id || '',
        '‡∫™‡∫∞‡∫ñ‡∫≤‡∫ô‡∫∞‡∫Å‡∫≤‡∫ô‡∫à‡ªà‡∫≤‡∫ç': order.payment_status || '',
        '‡∫ß‡∫±‡∫ô‡∫ó‡∫µ‡∫™‡∫±‡ªà‡∫á‡∫ä‡∫∑‡ªâ': order.order_date || '',
        '‡∫ß‡∫±‡∫ô‡∫ó‡∫µ‡∫≠‡∫±‡∫ö‡ªÄ‡∫î‡∫î': order.updated_at || '',
        // Also include mapped fields
        '‡∫•‡∫∞‡∫´‡∫±‡∫î‡∫Å‡∫≤‡∫ô‡∫™‡∫±‡ªà‡∫á‡∫ä‡∫∑‡ªâ': order.order_id || '',
        '‡∫ß‡∫±‡∫ô‡∫ó‡∫µ‡∫ö‡ªç‡∫•‡∫¥‡∫Å‡∫≤‡∫ô': order.service_date || '',
        '‡ªÄ‡∫ß‡∫•‡∫≤‡∫ö‡ªç‡∫•‡∫¥‡∫Å‡∫≤‡∫ô': order.service_time || '',
        '‡∫õ‡∫∞‡ªÄ‡∫û‡∫î‡∫ö‡ªç‡∫•‡∫¥‡∫Å‡∫≤‡∫ô (‡ªÅ‡∫õ)': order.service_type || '',
        '‡∫™‡∫∞‡∫ñ‡∫≤‡∫ô‡∫∞': order.status || ''
      }));
      
      // Create CSV data with Papa Parse
      const csvData = Papa.unparse(exportData, {
        header: true,
        encoding: 'utf8'
      });
      
      // Add UTF-8 BOM to ensure proper encoding in Excel for Lao text
      const BOM = '\uFEFF';
      const csvWithBOM = BOM + csvData;
      
      // Create blob with proper MIME type
      const blob = new Blob([csvWithBOM], { 
        type: 'text/csv;charset=utf-8;' 
      });
      
      const url = URL.createObjectURL(blob);
      
      // Create download link
      const link = document.createElement('a');
      link.setAttribute('href', url);
      
      // Generate filename with Lao text and current date
      const currentDate = new Date().toISOString().split('T')[0];
      const filename = `‡∫•‡∫≤‡∫ç‡∫á‡∫≤‡∫ô‡∫Å‡∫≤‡∫ô‡ªÉ‡∫ä‡ªâ‡∫ö‡ªç‡∫•‡∫¥‡∫Å‡∫≤‡∫ô-${currentDate}.csv`;
      
      link.setAttribute('download', filename);
      link.style.visibility = 'hidden';
      
      // Trigger download
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      // Clean up the URL object
      URL.revokeObjectURL(url);
      
      console.log('‚úÖ Export successful');
      
    } catch (error) {
      console.error('‚ùå Export error:', error);
      alert('‡ªÄ‡∫Å‡∫µ‡∫î‡∫Ç‡ªç‡ªâ‡∫ú‡∫¥‡∫î‡∫û‡∫≤‡∫î‡ªÉ‡∫ô‡∫Å‡∫≤‡∫ô‡∫™‡∫ª‡ªà‡∫á‡∫≠‡∫≠‡∫Å‡∫Ç‡ªç‡ªâ‡∫°‡∫π‡∫ô. ‡∫Å‡∫∞‡∫•‡∫∏‡∫ô‡∫≤‡∫•‡∫≠‡∫á‡ªÉ‡ªù‡ªà.');
    }
  };

  // Enhanced print functionality
  const handlePrint = () => {
    try {
      const originalTitle = document.title;
      document.title = `‡∫•‡∫≤‡∫ç‡∫á‡∫≤‡∫ô‡∫Å‡∫≤‡∫ô‡ªÉ‡∫ä‡ªâ‡∫ö‡ªç‡∫•‡∫¥‡∫Å‡∫≤‡∫ô - ${new Date().toLocaleDateString('lo-LA')}`;
      
      setTimeout(() => {
        window.print();
        setTimeout(() => {
          document.title = originalTitle;
        }, 1000);
      }, 300);
      
    } catch (error) {
      console.error('‚ùå Print error:', error);
      alert('‡ªÄ‡∫Å‡∫µ‡∫î‡∫Ç‡ªç‡ªâ‡∫ú‡∫¥‡∫î‡∫û‡∫≤‡∫î‡ªÉ‡∫ô‡∫Å‡∫≤‡∫ô‡∫û‡∫¥‡∫°. ‡∫Å‡∫∞‡∫•‡∫∏‡∫ô‡∫≤‡∫•‡∫≠‡∫á‡ªÉ‡ªù‡ªà.');
    }
  };

  // Initial data fetch on component mount
  useEffect(() => {
    fetchServiceOrders();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Refetch data when growth rate type changes
  useEffect(() => {
    if (serviceOrders.length > 0) {
      processDataForCharts(serviceOrders);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [filterParams.growthRateType]);

  return {
    filterOpen,
    toggleFilter,
    filterParams,
    handleFilterChange,
    handleDateChange,
    handleServiceTypeChange,
    handleGrowthRateTypeChange,
    applyFilters,
    resetFilters,
    usageData,
    summaryData,
    loading,
    error,
    debugInfo,
    handleExport,
    handlePrint,
    serviceOrders,
    useMockData,
    testAPI
  };
};